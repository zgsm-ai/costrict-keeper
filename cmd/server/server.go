package server

import (
	"context"
	"costrict-keeper/cmd/root"
	"costrict-keeper/controllers"
	_ "costrict-keeper/docs" // docs is generated by Swag CLI
	"costrict-keeper/internal/config"
	"costrict-keeper/internal/env"
	"costrict-keeper/internal/logger"
	"costrict-keeper/internal/middleware"
	"costrict-keeper/internal/utils"
	"costrict-keeper/services"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/spf13/cobra"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

var listenAddr string

var serverCmd = &cobra.Command{
	Use:   "server",
	Short: "start http server",
	Run: func(cmd *cobra.Command, args []string) {
		if err := startServer(); err != nil {
			logger.Fatal(err)
		}
	},
}

/**
 * Start HTTP server with all services
 * @returns {error} Returns error if server startup fails, nil on success
 * @description
 * - Initializes Gin router with default middleware
 * - Creates server service and service manager instances
 * - Registers API routes and controllers
 * - Starts all managed services
 * - Launches monitoring and log reporting goroutines
 * - Determines listening address from command line or config
 * - Starts HTTP server on both TCP port and Unix socket for cross-platform support
 * - Supports Windows, Linux, and Darwin platforms automatically
 * @throws
 * - Service startup errors
 * - HTTP server startup errors
 * @example
 * err := startServer()
 * if err != nil {
 *     logger.Fatal(err)
 * }
 */
func startServer() error {
	// Implement process uniqueness protection using PID file
	if err := ensureSingleInstance(); err != nil {
		return fmt.Errorf("failed to ensure single instance: %w", err)
	}
	config.ReloadConfig(true)
	config.LoadSpec()
	// Determine listening address: prioritize command line arguments, then use configuration file
	address := config.App().Listen
	if listenAddr != "" {
		address = listenAddr
	}
	if port := getPortFromAddress(address); port != 0 {
		env.ListenPort = port
	}
	env.Daemon = true

	server := services.NewServer(config.App())
	if err := server.Init(); err != nil {
		return err
	}
	server.StartAllService()
	// Initialize services
	router := gin.Default()
	// 添加指标统计中间件
	router.Use(middleware.MetricsMiddleware())

	apiController := controllers.NewAPIController(server)
	apiController.RegisterRoutes(router)

	// Register tunnel management routes
	serviceController := controllers.NewServiceController(server.Services())
	serviceController.RegisterRoutes(router)

	componentController := controllers.NewComponentController(server.Components())
	componentController.RegisterRoutes(router)

	// Register swagger routes
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Start all services, monitoring and log reporting
	go server.StartMonitoring()
	go server.StartReportMetrics()
	go server.StartLogReporting()
	go server.StartMidnightRooster()

	// Create listeners for both TCP and Unix socket
	listenerConfig := &ListenerConfig{
		TcpAddr:    address,
		SocketName: "costrict.sock",
		SocketDir:  "",
	}

	listeners, socketPath, err := CreateListeners(listenerConfig)
	if err != nil {
		logger.Fatal("Failed to create listeners:", err)
	}

	// Create HTTP server
	srv := &http.Server{
		Handler: router,
	}

	// Create context for graceful shutdown
	quit := make(chan os.Signal, 1)
	// Listen for interrupt signals
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Start HTTP server on all listeners
	for i, listener := range listeners {
		go func(idx int, ln net.Listener) {
			addr := ln.Addr().String()
			network := ln.Addr().Network()
			logger.Infof("Server starting on %s://%s", network, addr)

			if err := srv.Serve(ln); err != nil && err != http.ErrServerClosed {
				logger.Fatalf("Server failed to start on %s://%s: %v", network, addr, err)
			}
		}(i, listener)
	}

	// Wait for interrupt signal
	<-quit
	logger.Info("Server is shutting down...")

	// Create shutdown context with 5 second timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Gracefully shutdown HTTP server
	if err := srv.Shutdown(ctx); err != nil {
		logger.Fatal("Server forced to shutdown:", err)
	}

	// Clean up Unix socket file if it exists
	if socketPath != "" {
		if _, err := os.Stat(socketPath); err == nil {
			if err := os.Remove(socketPath); err != nil {
				logger.Error("Failed to remove socket file:", err)
			} else {
				logger.Info("Socket file removed:", socketPath)
			}
		}
	}

	// Gracefully shutdown other services
	server.StopAllService(ctx)
	services.UpdateCostrictStatus("exited")
	cleanupPidFile()

	logger.Info("Server exited gracefully")
	return nil
}

/**
* Ensure only one instance of the server is running using PID file mechanism
* @returns {error} Returns error if another instance is already running, nil on success
* @description
* - Creates PID file in system temp directory with name "costrict.pid"
* - Checks if PID file exists and if the process is still running
* - Handles stale PID files from crashed processes
* - Writes current process ID to PID file
* - Supports cross-platform operation (Windows, Linux, macOS)
* @throws
* - PID file creation errors
* - Process running check errors
* - File permission errors
* @example
* if err := ensureSingleInstance(); err != nil {
*     logger.Fatal("Another instance is already running:", err)
* }
 */
func ensureSingleInstance() error {
	// Get PID file path in temp directory
	pidFile := getPidFilePath()

	// Check if PID file exists
	if _, err := os.Stat(pidFile); err == nil {
		// PID file exists, read it
		pidData, err := os.ReadFile(pidFile)
		if err != nil {
			return fmt.Errorf("failed to read PID file: %w", err)
		}

		pidStr := string(pidData)
		pid, err := strconv.Atoi(pidStr)
		if err != nil {
			// Invalid PID format, remove stale file
			logger.Warn("Found invalid PID in PID file, removing:", pidFile)
			if err := os.Remove(pidFile); err != nil {
				return fmt.Errorf("failed to remove invalid PID file: %w", err)
			}
		} else {
			// Check if process is still running
			if running, err := utils.IsProcessRunning(pid); err == nil && running {
				return fmt.Errorf("another instance is already running with PID %d", pid)
			} else {
				// Process is not running, remove stale PID file
				logger.Info("Found stale PID file for non-running process, removing:", pidFile)
				if err := os.Remove(pidFile); err != nil {
					return fmt.Errorf("failed to remove stale PID file: %w", err)
				}
			}
		}
	} else {
		runDir := filepath.Join(env.CostrictDir, "run")
		if err := os.MkdirAll(runDir, 0755); err != nil {
			logger.Errorf("Failed to mkdir '%s': %v", runDir, err)
			return err
		}
	}

	// Write current PID to file
	currentPid := os.Getpid()
	pidStr := strconv.Itoa(currentPid)
	if err := os.WriteFile(pidFile, []byte(pidStr), 0644); err != nil {
		return fmt.Errorf("failed to write PID file: %w", err)
	}

	logger.Info("Created PID file:", pidFile, "with PID:", currentPid)
	return nil
}

/**
* Get platform-specific PID file path
* @returns {string} Full path to PID file
* @description
* - Uses '.costrict/run' for PID file location
* - Appends "costrict.pid" filename
* - Provides cross-platform path handling
* @example
* pidPath := getPidFilePath()
* fmt.Printf("PID file path: %s", pidPath)
 */
func getPidFilePath() string {
	return filepath.Join(env.CostrictDir, "run", "costrict.pid")
}

/**
* Clean up PID file on server shutdown
* @description
* - Removes PID file created during startup
* - Logs removal operation
* - Handles file not found errors gracefully
* @example
* cleanupPidFile()
 */
func cleanupPidFile() {
	pidFile := getPidFilePath()
	if _, err := os.Stat(pidFile); err == nil {
		if err := os.Remove(pidFile); err != nil {
			logger.Error("Failed to remove PID file:", err)
		} else {
			logger.Info("Removed PID file:", pidFile)
		}
	}
}

/**
 * Extract port number from listen address
 * @param {string} address - Listen address (e.g., ":8080", "localhost:8080", "192.168.1.1:8080")
 * @returns {int} Returns port number as integer, 0 if parsing fails
 * @description
 * - Parses various address formats to extract port number
 * - Handles addresses with or without host part
 * - Returns 0 if port cannot be parsed
 * @example
 * port := getPortFromAddress(":8080")  // returns 8080
 * port := getPortFromAddress("localhost:3000")  // returns 3000
 */
func getPortFromAddress(address string) int {
	if address == "" {
		return 0
	}

	// If address starts with ":", remove ":" and return the remaining part
	if address[0] == ':' {
		if len(address) > 1 {
			portStr := address[1:]
			var port int
			_, err := fmt.Sscanf(portStr, "%d", &port)
			if err != nil {
				return 0
			}
			return port
		}
		return 0
	}

	// Find the position of the last ":"
	lastColon := -1
	for i := len(address) - 1; i >= 0; i-- {
		if address[i] == ':' {
			lastColon = i
			break
		}
	}

	if lastColon == -1 {
		return 0
	}

	// Return the part after ":"
	if lastColon < len(address)-1 {
		portStr := address[lastColon+1:]
		var port int
		_, err := fmt.Sscanf(portStr, "%d", &port)
		if err != nil {
			return 0
		}
		return port
	}

	return 0
}

func init() {
	serverCmd.Flags().SortFlags = false
	serverCmd.Flags().StringVarP(&listenAddr, "listen", "l", "", "Server listening address (e.g., ':8080')")
	root.RootCmd.AddCommand(serverCmd)
}
